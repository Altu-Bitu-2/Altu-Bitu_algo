#include <iostream>
#include <vector>

using namespace std;
const int MOD = 10007; //10007로 나눈 나머지를 구하기 때문에 미리 선언.

int fillTile(int n) { // 타일 채우는 함수. 직사각형을 채우는 방법의 수%10007을 반환한다. 
    vector<int> dp(n + 1, 0); // dp를 사용하기 위한 백터 변수 생성하고 0으로 초기화

    if (n == 1) { //인덱스 에러 안나도록 n이 1일 경우 바로 리턴
        return 1;
    }

    //너비 1, 2인 타일 채우는 경우의 수 미리 초기화
    dp[1] = 1; //너비가 1이면 1
    dp[2] = 3; //너비가 2이면 3 임을 미리 초기화
    for (int i = 3; i <= n; i++) { //너비가 3인 것 부터 n까지 반복 계산
        dp[i] = dp[i - 1] + 2 * dp[i - 2]; // dp에 사용되는 공식 사용. i-1일 때의 총 개수와 i-2일 때의 개수*2의 합이 된다.
        dp[i] %= MOD; //구하는 과정에서 int 범위 초과할 수 있으므로 마지막에 한 번이 아니라 중간 중간 모듈러 연산을 해줘야 함
    }
    return dp[n]; // 직사각형을 채우는 방법의 수 %10007을 리턴한다. 
}

/**
 * 너비를 인덱스로 써서 n까지의 너비를 채우는 방법의 수를 저장하자!
 *
 * 우선, 너비 1은 2(높이)x1(너비) 타일로 채우는 경우밖에 없음
 * 너비 2는 1x2 2개와 2x2 1개 총 2 경우 + 너비 1에 2x1 타일을 더한 1 경우 -> 3 경우
 *
 * 그 후, 너비 3부터는 각각 너비 1, 2만큼을 뺀 타일에서 1, 2 너비 타일을 각각 더하는 경우를 생각해주자
 * 이때, 중복 경우의 수가 생기지 않도록 너비 2의 경우에서 1에서 더한 경우는 빼줌
 * -> dp[n] = (너비 1인 타일 채우는 경우의 수 = 1) * dp[n - 1]
 *          + (너비 2인 타일 채우는 경우의 수 = 2) * dp[n - 2]
 *
 * -> dp[n] = 1 * dp[n - 1] + 2 * dp[n - 2] (n >= 3)
 *
 * !주의! 모듈러 연산 해야함
 */

int main() {
    int n; //입력받는 변수 선언

    //입력
    cin >> n;

    //연산 & 출력
    cout << fillTile(n);
    return 0; // 프로그램 종료
}