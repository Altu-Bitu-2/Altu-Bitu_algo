#include <iostream>
#include <vector>

using namespace std;
const int MOD = 10007; // 결과값이 10 007로 나눈 나머지이기 때문에 미리 설정해둔다. 

//길이 N에서 일의 자리 수가 0 ~ 9인 오르막 수 모두 더하는 함수
int sumLastCnt(vector<int> &arr) {
    int ans = 0; // 반환할 변수 생성
    for (int i = 0; i < arr.size(); i++) { // 길이 n에서 일의 자리가 가능한 배열 내부의 값을 모두 더한다
        ans += arr[i]; // 배열 값을 변수에 더한다. 
        ans %= MOD; // 매번 mod처리를 해주어 int값을 넘어가지 않도록 한다. 
    }
    return ans; //가능한 모든 오르막 수를 반환한다. 
}

// 오르막 수를 모두 구하는 함수. sumLastCnt를 리턴하여 오르막 수를 모두 더한 값을 최종 반환한다. 
int upNumberCnt(int n) {
	// 수의 길이가 n+1이고, 일의 자리수가 10가지가 될 수 있는 dp 배열 생성. [n+1][10]이다. 
	// 뒤의 백터를 1로 초기화 한 것은 연산을 편하게 하기 위해서. 
    vector<vector<int>> dp(n + 1, vector<int>(10, 1)); 
	

    for (int i = 2; i <= n; i++) { //수의 길이가 2인 것 부터 n인 것 까지 연산
        for (int j = 1; j < 10; j++) {  // 일의 자리 수가 0일 때를 제외하고 1부터 9까지 확인 
            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; // [i][j] 를 구하기 위한 공식 사용. j보다 작은 수로 끝나는 길이 i-1로 끝나는 오르막 개수와 j로 끝나는 길이 i-1인 오르막 개수를 더한다. 
            dp[i][j] %= MOD; // 매번 모드 처리를 해준다. 
        }
    }
    return sumLastCnt(dp[n]); //카운트 해주는 함수 호출
}

/**
 * dp[i][j] = 수의 길이가 i이고, 일의 자리 수가 j인 오르막 수의 개수
 *
 * -> (j보다 작은 수 or j와 같은 수) + j를 하면 오르막 수가 됨
 * -> j보다 작은 수로 끝나는 길이 i - 1 인 오르막 수 개수 + j로 끝나는 길이 i - 1 인 오르막 수 개수
 * -> j보다 작은 수로 끝나고 길이가 i - 1 인 오르막 수의 접근은 길이 i인 오르막 수에서 마지막 수를 j로 대체하는 것으로 해결 가능
 * => dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
 *
 * dp 배열 채운 후, 길이가 n이고 일의 자리 수가 0 ~ 9인 오르막 수 개수 모두 더하면 됨!
 *
 * ex. 길이가 2인 오르막 수의 개수를 구해야 한다면
 *      0  1  2  3  4  5  6  7  8  9
 *  -------------------------------
 *  1 : 1  1  1  1  1  1  1  1  1  1
 *  2 : 1  2  3  4  5  6  7  8  9  10
 *  -> 2행의 값을 모두 더해서 출력!
 *
 *  해당 풀이는 연산 편하게 하기 위해 미리 dp 값 1로 초기화
 *  !주의! 마지막에 길이 n인 오르막 수 모두 더할 때도 모듈러 연산 해야함
 */

int main() {
    int n; // 입력 받는 변수 생성

    //입력
    cin >> n;

    //연산 & 출력
    cout << upNumberCnt(n);
    return 0; // 프로그램 종료
}